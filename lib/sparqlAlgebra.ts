import equal = require('fast-deep-equal/es6');
import { Quad } from '@rdfjs/types';
import * as RDF from '@rdfjs/types'
import { termToString } from 'rdf-string';
import {
    AggregateExpression,
    BgpPattern,
    ClearDropOperation,
    CopyMoveAddOperation,
    CreateOperation,
    Expression,
    FilterPattern,
    GraphPattern,
    GraphQuads,
    GroupPattern,
    InsertDeleteOperation,
    IriTerm,
    LoadOperation,
    Ordering,
    Pattern,
    PropertyPath,
    Query,
    SelectQuery,
    SparqlQuery,
    Triple,
    Update,
    UpdateOperation, ValuesPattern,
    Variable,
    VariableExpression,
    Wildcard
} from 'sparqljs';
import * as Algebra from './algebra';
import Factory from './factory';
import Util from './util';

const Parser = require('sparqljs').Parser;
const types = Algebra.types;

let variables = new Set<string>();
let varCount = 0;
let useQuads = false;
let factory: Factory;

/**
 * Translates the given SPARQL query to SPARQL Algebra.
 * @param sparql - Either a SPARQL string or an object generated by sparql.js
 * @param options - Optional options object. Current options:
 *                    * dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.
 *                    * quads: Boolean indicating whether triples should be converted to Quads (consumes GRAPH statements). Default false.
 *                    * prefixes: Pre-defined prefixes for the given query. Default empty.
 *                    * baseIRI: Base IRI that should be used for the query. Default undefined (throws error if required).
 * @returns {Operation}
 */
export default function translate(sparql: SparqlQuery | string, options?:
    {
        dataFactory?: RDF.DataFactory,
        quads?: boolean,
        prefixes?: {[prefix: string]: string},
        baseIRI?: string,
        blankToVariable?: boolean
        sparqlStar?: boolean;
    }) : Algebra.Operation
{
    options = options || {};
    factory = new Factory(options.dataFactory);

    let query: SparqlQuery;
    if (isString(sparql))
    {
        let parser = new Parser(options);
        // resets the identifier counter used for blank nodes
        // provides nicer and more consistent output if there are multiple calls
        parser._resetBlanks();
        query = parser.parse(sparql);
    } else {
        query = sparql;
    }

    return translateQuery(query, options.quads, options.blankToVariable);
}

function translateQuery(sparql: SparqlQuery, quads?: boolean, blankToVariable?: boolean) : Algebra.Operation
{
    // this set is filled in during the inScopeVariables call
    variables = new Set();
    varCount = 0;
    useQuads = Boolean(quads);

    // Assume this is an empty query
    if (!sparql.type)
        return factory.createNop();

    if (sparql.type !== 'query' && sparql.type !== 'update')
        throw new Error('Translate only works on complete query or update objects.');

    let res: Algebra.Operation;

    // find ALL variables here to fill `variables` array
    findAllVariables(sparql);

    if (sparql.type === 'query') {
        // group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE
        const group: GroupPattern = { type: 'group', patterns: sparql.where || [] };
        res = translateGroupGraphPattern(group);
        res = translateAggregates(sparql, res);
    }
    else if(sparql.type === 'update') {
        res = translateUpdate(sparql);
    }
    if (blankToVariable) {
        res = translateBlankNodesToVariables(res!);
    }

    return res!;
}

function isString(str: any): str is string
{
    return typeof str === 'string';
}

function isTerm(term: any) : term is RDF.Term
{
    return Boolean(term?.termType);
}

// This is not completely correct but this way we also catch SPARQL.js triples
function isTriple(triple: any) : triple is RDF.Quad {
    return triple.subject && triple.predicate && triple.object;
}

function isVariable(term: any) : term is RDF.Variable
{
    return term?.termType === 'Variable';
}

// Will be used to make sure new variables don't overlap
function findAllVariables(thingy: any): void
{
    if (isTerm(thingy))
    {
        if (isVariable(thingy))
        {
            // Variables don't store the `?`
            variables.add(`?${thingy.value}`);
        }
    }
    else if (Array.isArray(thingy))
    {
        for (const entry of thingy)
            findAllVariables(entry);
    }
    else if (thingy && typeof thingy === 'object')
    {
        for (let key of Object.keys(thingy))
        {
            // Some variables are hidden in keys (specifically for VALUES)
            if (key.startsWith('?'))
                variables.add(key);
            findAllVariables(thingy[key]);
        }
    }
}

// 18.2.1
function inScopeVariables(thingy: SparqlQuery | Pattern | PropertyPath | RDF.Term) : {[key: string]: RDF.Variable}
{
    let inScope: {[key: string]: RDF.Variable} = {};

    if (isTriple(thingy))
    {
        // Note that this could both be an actual Quad or a SPARQL.js triple (without graph)
        const result = [
            inScopeVariables(thingy.subject),
            inScopeVariables(thingy.predicate),
            inScopeVariables(thingy.object),
            thingy.graph ? inScopeVariables(thingy.graph) : {}
        ];
        Object.assign(inScope, ...result);
    }
    else if (isTerm(thingy))
    {
        if (isVariable(thingy))
            inScope[thingy.value] = thingy;
    }
    else if (thingy.type === 'bgp')
    {
        // Slightly cheating but this is a subset of what we support so is fine
        const quads = thingy.triples as Quad[];
        Object.assign(inScope, ...quads.map(inScopeVariables));
    }
    else if (thingy.type === 'path') {
      // A path predicate should not have variables but just iterating so we could theoretically support this
      Object.assign(inScope, ...thingy.items.map(inScopeVariables));
    }
    else if (thingy.type === 'group' || thingy.type === 'union' || thingy.type === 'optional') {
      Object.assign(inScope, ...thingy.patterns.map(inScopeVariables));
    }
    else if (thingy.type === 'service' || thingy.type === 'graph') {
      Object.assign(inScope, inScopeVariables(thingy.name));
      Object.assign(inScope, ...thingy.patterns.map(inScopeVariables));
    }
    else if (thingy.type === 'bind') {
        Object.assign(inScope, inScopeVariables(thingy.variable));
    }
    else if (thingy.type === 'values')
    {
        if (thingy.values.length > 0)
        {
            const vars = Object.keys(thingy.values[0]).map(v => factory.createTerm(v));
            Object.assign(inScope, ...vars.map(inScopeVariables));
        }
    }
    else if (thingy.type === 'query')
    {
        if (thingy.queryType === 'SELECT' || thingy.queryType === 'DESCRIBE')
        {
            if (thingy.where && thingy.variables.some(Util.isWildcard))
                Object.assign(inScope, ...thingy.where.map(inScopeVariables));
            for (const v of thingy.variables)
            {
                if (isVariable(v))
                    Object.assign(inScope, inScopeVariables(v));
                else if ((v as VariableExpression).variable)
                    Object.assign(inScope, inScopeVariables((v as VariableExpression).variable));
            }
            if (thingy.queryType === 'SELECT')
            {
                if (thingy.group)
                {
                    // Grouping can be a VariableExpression, typings are wrong
                    for (const g of thingy.group)
                    {
                        if ((g as VariableExpression).variable)
                            Object.assign(inScope, inScopeVariables((g as VariableExpression).variable));
                    }
                }
                if (thingy.values)
                {
                    const values: ValuesPattern = { type: 'values', values: thingy.values };
                    Object.assign(inScope, inScopeVariables(values));
                }
            }
        }
    }

    return inScope;
}

function translateGroupGraphPattern(thingy: Pattern) : Algebra.Operation
{
    // 18.2.2.1
    // already done by sparql parser

    // 18.2.2.2
    let filters: FilterPattern[] = [];
    let nonfilters: Pattern[] = [];
    if ('patterns' in thingy)
        for (let pattern of thingy.patterns)
            (pattern.type === 'filter' ? filters : nonfilters).push(pattern);

    // 18.2.2.3
    // 18.2.2.4
    // 18.2.2.5
    if (thingy.type === 'bgp')
        return translateBgp(thingy);

    // 18.2.2.6
    let result: Algebra.Operation;
    if (thingy.type === 'union')
        result = factory.createUnion(nonfilters.map((p: any) =>
        {
            // sparqljs doesn't always indicate the children are groups
            if (p.type !== 'group')
                p = { type: 'group', patterns: [p] };
            return translateGroupGraphPattern(p);
        }));
    else if (thingy.type === 'graph')
        // need to handle this separately since the filters need to be in the graph
        return translateGraph(thingy);
    else if (thingy.type === 'group')
        result = nonfilters.reduce(accumulateGroupGraphPattern, factory.createBgp([]));
    // custom values operation
    else if (thingy.type === 'values')
        result = translateInlineData(thingy);
    else if (thingy.type === 'query')
        result = translateQuery(thingy, useQuads, false);
    else
        throw new Error(`Unexpected type: ${thingy.type}`);


    if (filters.length > 0)
    {
        let expressions: Algebra.Expression[] = filters.map(filter => translateExpression(filter.expression));
        if (expressions.length > 0)
            result = factory.createFilter(result, expressions.reduce((acc, exp) => factory.createOperatorExpression('&&', [acc, exp])));
    }

    return result;
}

function translateExpression(exp: Expression | RDF.Term | Wildcard) : Algebra.Expression
{
    if (Util.isSimpleTerm(exp))
        return factory.createTermExpression(exp);
    if (Util.isQuad(exp)) {
        if (Util.hasQuadVariables(exp))
            return factory.createOperatorExpression('triple', [
              translateExpression(exp.subject),
              translateExpression(exp.predicate),
              translateExpression(exp.object),
            ]);
        else
            return factory.createTermExpression(exp);
    }
    if (Util.isWildcard(exp))
        return factory.createWildcardExpression();
    if ('aggregation' in exp)
        return factory.createAggregateExpression(exp.aggregation, translateExpression(exp.expression), Boolean(exp.distinct), exp.separator);
    if ('function' in exp)
        // Outdated typings
        return factory.createNamedExpression(<RDF.NamedNode><unknown> exp.function, exp.args.map(translateExpression));
    if ('operator' in exp)
    {
        if (exp.operator === 'exists' || exp.operator === 'notexists')
            return factory.createExistenceExpression(exp.operator === 'notexists', translateGroupGraphPattern(exp.args[0] as Pattern));
        if (exp.operator === 'in' || exp.operator === 'notin')
            exp.args = [exp.args[0]].concat(exp.args[1]); // sparql.js uses 2 arguments with the second one being a list
        return factory.createOperatorExpression(exp.operator, exp.args.map(translateExpression));
    }
    throw new Error(`Unknown expression: ${JSON.stringify(exp)}`);
}

function translateBgp(thingy: BgpPattern) : Algebra.Operation
{
    let patterns: Algebra.Pattern[] = [];
    let joins: Algebra.Operation[] = [];
    for (let t of thingy.triples)
    {
        if ('pathType' in t.predicate)
        {
            // translatePath returns a mix of Quads and Paths
            let path = translatePath(t as Triple & { predicate: PropertyPath });
            for (let p of path)
            {
                if (p.type === types.PATH)
                {
                    if (patterns.length > 0)
                        joins.push(factory.createBgp(patterns));
                    patterns = [];
                    joins.push(p);
                }
                else
                    patterns.push(p);
            }
        }
        else
            patterns.push(translateQuad(t));
    }
    if (patterns.length > 0)
        joins.push(factory.createBgp(patterns));
    if (joins.length === 1)
        return joins[0];
    return factory.createJoin(joins);
}

function translatePath(triple: Triple & { predicate: PropertyPath }) : (Algebra.Path | Algebra.Pattern)[]
{
    let sub = triple.subject;
    let pred = translatePathPredicate(triple.predicate);
    let obj = triple.object;

    return simplifyPath(sub, pred, obj);
}

function translatePathPredicate(predicate: IriTerm | PropertyPath) : Algebra.PropertyPathSymbol
{
    if (Util.isSimpleTerm(predicate))
    {
        if (predicate.termType === 'NamedNode')
            return factory.createLink(predicate);
        else
            throw new Error(`Path predicate should be a NamedNode, got ${JSON.stringify(predicate)}`);
    }

    if (predicate.pathType === '^')
        return factory.createInv(translatePathPredicate(predicate.items[0]));

    if (predicate.pathType === '!')
    {
        // negation is either over a single predicate or a list of disjuncted properties
        let normals: RDF.NamedNode[] = [];
        let inverted: RDF.NamedNode[] = [];
        let items: (IriTerm | PropertyPath)[];
        if ('pathType' in predicate.items[0] && predicate.items[0].pathType === '|')
            items = predicate.items[0].items; // the | element
        else
            items = predicate.items;

        for (let item of items)
        {
            if (Util.isSimpleTerm(item))
                normals.push(item);
            else if (item.pathType === '^')
                inverted.push(item.items[0] as RDF.NamedNode);
            else
                throw new Error(`Unexpected item: ${JSON.stringify(item)}`);
        }

        // NPS elements do not have the LINK function
        let normalElement = factory.createNps(normals);
        let invertedElement = factory.createInv(factory.createNps(inverted));

        if (inverted.length === 0)
            return normalElement;
        if (normals.length === 0)
            return invertedElement;
        return factory.createAlt([ normalElement, invertedElement, ]);
    }

    if (predicate.pathType === '/')
        return factory.createSeq(predicate.items.map(translatePathPredicate));
    if (predicate.pathType === '|')
        return factory.createAlt(predicate.items.map(translatePathPredicate));
    if (predicate.pathType === '*')
        return factory.createZeroOrMorePath(translatePathPredicate(predicate.items[0]));
    if (predicate.pathType === '+')
        return factory.createOneOrMorePath(translatePathPredicate(predicate.items[0]));
    if (predicate.pathType === '?')
        return factory.createZeroOrOnePath(translatePathPredicate(predicate.items[0]));

    throw new Error(`Unable to translate path expression ${JSON.stringify(predicate)}`);
}

function simplifyPath(subject: RDF.Quad_Subject, predicate: Algebra.PropertyPathSymbol, object: RDF.Quad_Object) : (Algebra.Pattern | Algebra.Path)[]
{
    if (predicate.type === types.LINK)
        return [factory.createPattern(subject, predicate.iri, object)];

    if (predicate.type === types.INV)
        return simplifyPath(<RDF.Quad_Subject> object, predicate.path, subject);

    if (predicate.type === types.SEQ)
    {
        let joiner: RDF.Quad_Subject | RDF.Variable = subject;
        return Util.flatten(predicate.input.map((subOp, i) => {
            const nextJoiner = i === predicate.input.length - 1 ? object : generateFreshVar();
            const simplifiedPath = simplifyPath(joiner, subOp, nextJoiner);
            if (nextJoiner.termType === 'Variable') {
                joiner = nextJoiner;
            }
            return simplifiedPath;
        }));
    }

    return [ factory.createPath(subject, predicate, object) ];
}

function generateFreshVar() : RDF.Variable
{
    let v: string = `?var${varCount++}`;
    if (variables.has(v))
        return generateFreshVar();
    variables.add(v);
    return <RDF.Variable>factory.createTerm(v);
}

function translateQuad(quad: Triple) : Algebra.Pattern
{
    if ('pathType' in quad.predicate) {
        throw new Error('Trying to translate property path to quad.');
    }
    // Graphs are needed here
    // TODO: investigate if typings are wrong or if we internally add graphs to these
    return factory.createPattern(quad.subject, quad.predicate, quad.object, (quad as any).graph);
}

function translateGraph(graph: GraphPattern) : Algebra.Operation
{
    const group: GroupPattern = { type: 'group', patterns: graph.patterns };
    let result = translateGroupGraphPattern(group);
    if (useQuads)
        result = recurseGraph(result, graph.name);
    else
        result = factory.createGraph(result, graph.name);

    return result;
}

let typeVals = Object.values(types);
function recurseGraph(thingy: Algebra.Operation, graph: RDF.Term, replacement?: RDF.Variable) : Algebra.Operation
{
    if (thingy.type === types.GRAPH)
    {
        if (replacement) {
            // At this point we would lose track of the replacement which would result in incorrect results
            // This would indicate the library is not being used as intended though
            throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');
        }
        // In case there were nested GRAPH statements that were not recursed yet for some reason
        thingy = recurseGraph(thingy.input, thingy.name);
    }
    else if (thingy.type === types.SERVICE)
    {
        // Service blocks are not affected by enclosing GRAPH statements, so nothing is modified in this block.
        // See https://github.com/joachimvh/SPARQLAlgebra.js/pull/104#issuecomment-1838016303
    }
    else if (thingy.type === types.BGP)
        thingy.patterns = thingy.patterns.map(quad =>
        {
            if (replacement)
            {
                if (quad.subject.equals(graph)) quad.subject = replacement;
                if (quad.predicate.equals(graph)) quad.predicate = replacement;
                if (quad.object.equals(graph)) quad.object = replacement;
            }
            if (quad.graph.termType === 'DefaultGraph')
                quad.graph = graph;
            return quad;
        });
    else if (thingy.type === types.PATH)
    {
        if (replacement)
        {
            if (thingy.subject.equals(graph)) thingy.subject = replacement;
            if (thingy.object.equals(graph))  thingy.object = replacement;
        }
        if (thingy.graph.termType === 'DefaultGraph')
            thingy.graph = graph;
    }
    // need to replace variables in subqueries should the graph also be a variable of the same name
    // unless the subquery projects that variable
    else if (thingy.type === types.PROJECT && !replacement)
    {
        if (!thingy.variables.some(v => v.equals(graph)))
            replacement = generateFreshVar();
        thingy.input = recurseGraph(thingy.input, graph, replacement);
    }
    // this can happen if the query extends an expression to the name of the graph
    // since the extend happens here there should be no further occurrences of this name
    // if there are it's the same situation as above
    else if (thingy.type === types.EXTEND && !replacement)
    {
        if (thingy.variable.equals(graph))
            replacement = generateFreshVar();
        thingy.input = recurseGraph(thingy.input, graph, replacement);
    }
    else
    {
        for (let key of Object.keys(thingy))
        {
            if (Array.isArray(thingy[key]))
                thingy[key] = thingy[key].map((x: any) => recurseGraph(x, graph, replacement));
            else if (typeVals.indexOf(thingy[key].type) >= 0) // can't do instanceof on an interface
                thingy[key] = recurseGraph(thingy[key], graph, replacement);
            else if (replacement && isVariable(thingy[key]) && thingy[key].equals(graph))
                thingy[key] = replacement;
        }
    }

    return thingy;
}

function accumulateGroupGraphPattern(G: Algebra.Operation, E: Pattern) : Algebra.Operation
{
    if (E.type === 'optional')
    {
        // optional input needs to be interpreted as a group
        const A = translateGroupGraphPattern({ type: 'group', patterns: E.patterns });
        if (A.type === types.FILTER)
        {
            G = factory.createLeftJoin(G, A.input, A.expression);
        }
        else
            G = factory.createLeftJoin(G, A);
    }
    else if (E.type === 'minus')
    {
        // minus input needs to be interpreted as a group
        const A = translateGroupGraphPattern({ type: 'group', patterns: E.patterns });
        G = factory.createMinus(G, A);
    }
    else if (E.type === 'bind')
        G = factory.createExtend(G, <RDF.Variable>E.variable, translateExpression(E.expression));
    else if (E.type === 'service')
    {
        // transform to group so childnodes get parsed correctly
        const group: GroupPattern = { type: 'group', patterns: E.patterns };
        const A = factory.createService(translateGroupGraphPattern(group), E.name, E.silent);
        G = simplifiedJoin(G, A);
    }
    else
    {
        const A = translateGroupGraphPattern(E);
        G = simplifiedJoin(G, A);
    }

    return G;
}

function simplifiedJoin(G: Algebra.Operation, A: Algebra.Operation): Algebra.Operation
{
    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.
    if (G.type  === types.BGP && A.type === types.BGP)
        G = factory.createBgp([ ...G.patterns, ...A.patterns ]);
    // 18.2.2.8 (simplification)
    else if (G.type === types.BGP && G.patterns.length === 0)
        G = A;
    else if (A.type === types.BGP && A.patterns.length === 0)
    {} // do nothing
    else
        G = factory.createJoin([ G, A ]);
    return G;
}

function translateInlineData(values: any) : Algebra.Values
{
    let variables = <RDF.Variable[]>(values.values.length === 0 ? [] : Object.keys(values.values[0])).map(factory.createTerm.bind(factory));
    let bindings = values.values.map((binding: any) =>
    {
        let keys = Object.keys(binding);
        keys = keys.filter(k => binding[k] !== undefined);
        let map: any = {};
        for (let key of keys)
            map[key] = binding[key];
        return map;
    });
    return factory.createValues(variables, bindings);
}

// --------------------------------------- AGGREGATES
function translateAggregates(query: Query, res: Algebra.Operation) : Algebra.Operation
{
    // Typings for ConstructQuery are wrong and missing several fields so we will cast quite often to SelectQuery to have partial typings
    const select = query as SelectQuery;

    // 18.2.4.1
    const E: VariableExpression[] = [];

    const A: NodeJS.Dict<AggregateExpression> = {};
    select.variables = select.variables && select.variables.map(val => mapAggregate(val, A));
    select.having = select.having && select.having.map(val => mapAggregate(val, A));
    select.order = select.order && select.order.map(val => mapAggregate(val, A));

    // if there are any aggregates or if we have a groupBy (both result in a GROUP)
    if (select.group || Object.keys(A).length > 0)
    {
        const aggregates = Object.keys(A).map(v => translateBoundAggregate(<AggregateExpression> A[v], <RDF.Variable>factory.createTerm(v)));
        const vars: RDF.Variable[] = [];
        if (select.group)
        {
            for (const e of select.group)
            {
                if (Util.isSimpleTerm(e.expression)) {
                    vars.push(<RDF.Variable>e.expression); // this will always be a var, otherwise sparql would be invalid
                } else {
                    // Incorrect typings, e can have a variable, see for example group-variable test in sparql.js
                    const v = 'variable' in e ? <RDF.Variable>(e as any).variable : generateFreshVar();
                    res = factory.createExtend(res, v, translateExpression(e.expression));
                    vars.push(v);
                }

            }
        }
        res = factory.createGroup(res, vars, aggregates);
    }

    // 18.2.4.2
    if (select.having)
        for (let filter of select.having)
            res = factory.createFilter(res, translateExpression(filter));

    // 18.2.4.3
    if (query.values)
        res = factory.createJoin([ res, translateInlineData(query) ]);

    // 18.2.4.4
    let PV: (RDF.Variable | RDF.NamedNode)[] = [];

    if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE')
    {
        // Sort variables for consistent output
        if (query.variables.some((e: any) => e && Util.isWildcard(e)))
            PV = Object.values(inScopeVariables(query))
              .sort((left, right) => left.value.localeCompare(right.value));
        else
        {
            // Wildcard has been filtered out above
            for (let v of query.variables as Variable[])
            {
                // can have non-variables with DESCRIBE
                if (isVariable(v) || !('variable' in v))
                    PV.push(v);
                else if (v.variable) // ... AS ?x
                {
                    PV.push(v.variable);
                    E.push(v);
                }
            }
        }
    }

    // TODO: Jena simplifies by having a list of extends
    for (let v of E)
        res = factory.createExtend(res, <RDF.Variable>v.variable, translateExpression(v.expression));

    // 18.2.5
    // not using toList and toMultiset

    // 18.2.5.1
    if (select.order)
        res = factory.createOrderBy(res, select.order.map((exp: any) =>
        {
            let result = translateExpression(exp.expression);
            if (exp.descending)
                result = factory.createOperatorExpression('desc', [result]);
            return result;
        }));

    // 18.2.5.2
    // construct does not need a project (select, ask and describe do)
    if (query.queryType === 'SELECT')
        // Named nodes are only possible in a DESCRIBE so this cast is safe
        res = factory.createProject(res, PV as RDF.Variable[]);

    // 18.2.5.3
    if (select.distinct)
        res = factory.createDistinct(res);

    // 18.2.5.4
    if (select.reduced)
        res = factory.createReduced(res);

    // NEW: support for ask/construct/describe queries
    if (query.queryType === 'CONSTRUCT')
        res = factory.createConstruct(res, (query.template || []).map(translateQuad));
    else if (query.queryType === 'ASK')
        res = factory.createAsk(res);
    else if (query.queryType === 'DESCRIBE')
        res = factory.createDescribe(res, PV);

    // Slicing needs to happen after construct/describe
    // 18.2.5.5
    if (select.offset || select.limit)
        res = factory.createSlice(res, select.offset || 0, select.limit);

    if (select.from)
        res = factory.createFrom(res, select.from.default, select.from.named);

    return res;
}

type mapAggregateType = Variable | Wildcard | Expression | Ordering;

// rewrites some of the input sparql object to make use of aggregate variables
function mapAggregate (thingy: mapAggregateType, aggregates: NodeJS.Dict<AggregateExpression>) : any
{
    if ('type' in thingy && thingy.type === 'aggregate')
    {
        let found = false;
        let v;
        for (let key of Object.keys(aggregates))
        {
            if (equal(aggregates[key], thingy))
            {
                v = factory.createTerm(key);
                found = true;
                break;
            }
        }
        if (!found)
        {
            v = generateFreshVar();
            aggregates[termToString(v)] = thingy;
        }
        return v;
    }

    // non-aggregate expression
    if ('expression' in thingy && thingy.expression)
        return { ...thingy, expression: mapAggregate(thingy.expression, aggregates) };
    if ('args' in thingy && thingy.args)
        return { ...thingy, args: thingy.args.map(subthingy => mapAggregate(subthingy, aggregates)) };

    // Normal variable/wildcard
    return thingy;
}

function translateBoundAggregate (thingy: AggregateExpression, v: RDF.Variable) : Algebra.BoundAggregate
{
    if (thingy.type !== 'aggregate' || !thingy.aggregation)
        throw new Error(`Unexpected input: ${JSON.stringify(thingy)}`);

    const A  = <Algebra.BoundAggregate>translateExpression(thingy);
    A.variable = v;

    return A;
}

function translateUpdate (thingy: Update) : Algebra.Operation {
    if (thingy.updates.length === 1)
        return translateSingleUpdate(thingy.updates[0]);
    return factory.createCompositeUpdate(thingy.updates.map(translateSingleUpdate));
}

function translateSingleUpdate (thingy: UpdateOperation) : Algebra.Update {
    if ('type' in thingy) {
        if (thingy.type === 'load')
            return translateUpdateGraphLoad(thingy);
        if (thingy.type === 'clear' || thingy.type === 'create' || thingy.type === 'drop')
            return translateUpdateGraph(thingy);
        if (thingy.type === 'add' || thingy.type === 'copy' || thingy.type === 'move')
            return translateUpdateGraphShortcut(thingy);
    }
    else if (thingy.updateType === 'insertdelete' || thingy.updateType === 'deletewhere' || thingy.updateType === 'delete' || thingy.updateType === 'insert')
        return translateInsertDelete(thingy);

    throw new Error(`Unknown update type ${JSON.stringify(thingy)}`);
}

function translateInsertDelete (thingy: InsertDeleteOperation): Algebra.Update
{
    if (!useQuads)
        throw new Error('INSERT/DELETE operations are only supported with quads option enabled');

    let deleteTriples: Algebra.Pattern[] = [];
    let insertTriples: Algebra.Pattern[] = [];
    let where: Algebra.Operation;
    if (thingy.delete)
        deleteTriples = Util.flatten(thingy.delete.map(input => translateUpdateTriplesBlock(input, thingy.graph)));
    if (thingy.insert)
        insertTriples = Util.flatten(thingy.insert.map(input => translateUpdateTriplesBlock(input, thingy.graph)));
    if (thingy.where && thingy.where.length > 0) {
        where = translateGroupGraphPattern({ type: 'group', patterns: thingy.where });
        // Wrong typings, see test "using" in Sparql.js
        const using: { default: RDF.NamedNode[], named: RDF.NamedNode[] } | undefined = (thingy as any).using;
        if (using)
            where = factory.createFrom(where, using.default, using.named);
        else if (thingy.graph)
            // This is equivalent
            where = recurseGraph(where, thingy.graph);
    } else if (thingy.updateType === 'deletewhere' && deleteTriples.length > 0) {
        where = factory.createBgp(deleteTriples);
    }

    return factory.createDeleteInsert(
        deleteTriples.length > 0 ? deleteTriples : undefined,
        insertTriples.length > 0 ? insertTriples : undefined,
        where!,
    );
}

// UPDATE parsing will always return quads and have no GRAPH elements
function translateUpdateTriplesBlock (thingy: BgpPattern | GraphQuads, graph?: RDF.NamedNode): Algebra.Pattern[] {
    let currentGraph = graph;
    if (thingy.type === 'graph')
        currentGraph = thingy.name;
    let currentTriples = thingy.triples;
    if (currentGraph)
        currentTriples = currentTriples.map(triple => Object.assign(triple, { graph: currentGraph }));
    return currentTriples.map(translateQuad);
}

function translateUpdateGraph (thingy: CreateOperation | ClearDropOperation): Algebra.Update
{
    let source: 'DEFAULT' | 'NAMED' | 'ALL' | RDF.NamedNode;
    if (Util.isSimpleTerm(thingy.graph))
        source = thingy.graph;
    else if (thingy.graph.all)
        source = 'ALL';
    else if (thingy.graph.default)
        source = 'DEFAULT';
    else if (thingy.graph.named)
        source = 'NAMED';
    else
        source = thingy.graph.name!;

    switch (thingy.type)
    {
        case 'clear': return factory.createClear(source, thingy.silent);
        case 'create': return factory.createCreate(source as RDF.NamedNode, thingy.silent);
        case 'drop':  return factory.createDrop(source, thingy.silent);
    }
}

function translateUpdateGraphLoad (thingy: LoadOperation): Algebra.Load
{
    return factory.createLoad(thingy.source, thingy.destination as (RDF.NamedNode | undefined), thingy.silent);
}

function translateUpdateGraphShortcut (thingy: CopyMoveAddOperation): Algebra.Update
{
    const source: 'DEFAULT' | RDF.NamedNode = thingy.source.default ? 'DEFAULT' : <RDF.NamedNode> thingy.source.name;
    const destination: 'DEFAULT' | RDF.NamedNode = thingy.destination.default ? 'DEFAULT' : <RDF.NamedNode> thingy.destination.name;
    switch (thingy.type)
    {
        case 'copy': return factory.createCopy(source, destination, thingy.silent);
        case 'move': return factory.createMove(source, destination, thingy.silent);
        case 'add':  return factory.createAdd(source, destination, thingy.silent);
    }
}

function translateBlankNodesToVariables (res: Algebra.Operation) : Algebra.Operation
{
    const blankToVariableMapping: {[bLabel: string]: RDF.Variable} = {};
    const variablesRaw: {[vLabel: string]: boolean} = Array.from(variables).reduce((acc: {[vLabel: string]: boolean}, variable: string) => {
        acc[variable] = true;
        return acc;
    }, {});
    return Util.mapOperation(res, {
        [Algebra.types.DELETE_INSERT]: (op: Algebra.DeleteInsert) => {
            // Only relevant for INSERT operations as others should never contain blank nodes
            return { result: op, recurse: false };
        },
        [Algebra.types.PATH]: (op: Algebra.Path, factory: Factory) => {
            return {
                result: factory.createPath(
                    blankToVariable(op.subject),
                    op.predicate,
                    blankToVariable(op.object),
                    blankToVariable(op.graph),
                ),
                recurse: false,
            };
        },
        [Algebra.types.PATTERN]: (op: Algebra.Pattern, factory: Factory) => {
            return {
                result: factory.createPattern(
                    blankToVariable(op.subject),
                    blankToVariable(op.predicate),
                    blankToVariable(op.object),
                    blankToVariable(op.graph),
                ),
                recurse: false,
            };
        },
        [Algebra.types.CONSTRUCT]: (op: Algebra.Construct) => {
            // Blank nodes in CONSTRUCT templates must be maintained
            return {
                result: factory.createConstruct(translateBlankNodesToVariables(op.input), op.template),
                recurse: false,
            };
        },
    });

    function blankToVariable(term: RDF.Term): RDF.Term
    {
        if (term.termType === 'BlankNode') {
            let variable = blankToVariableMapping[term.value];
            if (!variable) {
                variable = Util.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);
                variablesRaw[variable.value] = true;
                blankToVariableMapping[term.value] = variable;
            }
            return variable;
        }
        return term;
  }
}
